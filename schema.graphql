"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `CountyCasesAll`."""
  allCountyCasesAlls(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CountyCasesAll`."""
    orderBy: [CountyCasesAllsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountyCasesAllCondition
  ): CountyCasesAllsConnection

  """Reads and enables pagination through a set of `CountyMeta`."""
  allCountyMetas(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CountyMeta`."""
    orderBy: [CountyMetasOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountyMetaCondition
  ): CountyMetasConnection

  """Reads and enables pagination through a set of `MsaCasesAll`."""
  allMsaCasesAlls(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MsaCasesAll`."""
    orderBy: [MsaCasesAllsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MsaCasesAllCondition
  ): MsaCasesAllsConnection

  """Reads and enables pagination through a set of `MsaMeta`."""
  allMsaMetas(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MsaMeta`."""
    orderBy: [MsaMetasOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MsaMetaCondition
  ): MsaMetasConnection

  """Reads and enables pagination through a set of `StateCasesAll`."""
  allStateCasesAlls(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StateCasesAll`."""
    orderBy: [StateCasesAllsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StateCasesAllCondition
  ): StateCasesAllsConnection

  """Reads and enables pagination through a set of `StateMeta`."""
  allStateMetas(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StateMeta`."""
    orderBy: [StateMetasOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StateMetaCondition
  ): StateMetasConnection

  """Reads and enables pagination through a set of `StatesHospitalization`."""
  allStatesHospitalizations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StatesHospitalization`."""
    orderBy: [StatesHospitalizationsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatesHospitalizationCondition
  ): StatesHospitalizationsConnection

  """Reads and enables pagination through a set of `StatesTesting`."""
  allStatesTestings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StatesTesting`."""
    orderBy: [StatesTestingsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatesTestingCondition
  ): StatesTestingsConnection

  """Reads and enables pagination through a set of `UsCasesAll`."""
  allUsCasesAlls(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UsCasesAll`."""
    orderBy: [UsCasesAllsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsCasesAllCondition
  ): UsCasesAllsConnection

  """Reads and enables pagination through a set of `UsHospitalization`."""
  allUsHospitalizations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UsHospitalization`."""
    orderBy: [UsHospitalizationsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsHospitalizationCondition
  ): UsHospitalizationsConnection

  """Reads and enables pagination through a set of `UsTesting`."""
  allUsTestings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UsTesting`."""
    orderBy: [UsTestingsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsTestingCondition
  ): UsTestingsConnection
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `CountyCasesAll` values."""
type CountyCasesAllsConnection {
  """A list of `CountyCasesAll` objects."""
  nodes: [CountyCasesAll]!

  """
  A list of edges which contains the `CountyCasesAll` and cursor to aid in pagination.
  """
  edges: [CountyCasesAllsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CountyCasesAll` you could get from the connection."""
  totalCount: Int!
}

type CountyCasesAll {
  date: String
  county: String
  stateName: String
  stateFipsCode: String
  countyFipsCode: String
  confirmedCases: Int
  deaths: Int
}

"""A `CountyCasesAll` edge in the connection."""
type CountyCasesAllsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CountyCasesAll` at the end of the edge."""
  node: CountyCasesAll
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `CountyCasesAll`."""
enum CountyCasesAllsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  COUNTY_ASC
  COUNTY_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
  COUNTY_FIPS_CODE_ASC
  COUNTY_FIPS_CODE_DESC
  CONFIRMED_CASES_ASC
  CONFIRMED_CASES_DESC
  DEATHS_ASC
  DEATHS_DESC
}

"""
A condition to be used against `CountyCasesAll` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CountyCasesAllCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `county` field."""
  county: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String

  """Checks for equality with the object’s `countyFipsCode` field."""
  countyFipsCode: String

  """Checks for equality with the object’s `confirmedCases` field."""
  confirmedCases: Int

  """Checks for equality with the object’s `deaths` field."""
  deaths: Int
}

"""A connection to a list of `CountyMeta` values."""
type CountyMetasConnection {
  """A list of `CountyMeta` objects."""
  nodes: [CountyMeta]!

  """
  A list of edges which contains the `CountyMeta` and cursor to aid in pagination.
  """
  edges: [CountyMetasEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CountyMeta` you could get from the connection."""
  totalCount: Int!
}

type CountyMeta {
  countyFipsCode: String
  stateFipsCode: String
  population: Int
  countyName: String
  stateName: String
  stateAbbr: String
  msaId: String
  msaName: String
  msaUrlName: String
}

"""A `CountyMeta` edge in the connection."""
type CountyMetasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CountyMeta` at the end of the edge."""
  node: CountyMeta
}

"""Methods to use when ordering `CountyMeta`."""
enum CountyMetasOrderBy {
  NATURAL
  COUNTY_FIPS_CODE_ASC
  COUNTY_FIPS_CODE_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
  POPULATION_ASC
  POPULATION_DESC
  COUNTY_NAME_ASC
  COUNTY_NAME_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  STATE_ABBR_ASC
  STATE_ABBR_DESC
  MSA_ID_ASC
  MSA_ID_DESC
  MSA_NAME_ASC
  MSA_NAME_DESC
  MSA_URL_NAME_ASC
  MSA_URL_NAME_DESC
}

"""
A condition to be used against `CountyMeta` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CountyMetaCondition {
  """Checks for equality with the object’s `countyFipsCode` field."""
  countyFipsCode: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String

  """Checks for equality with the object’s `population` field."""
  population: Int

  """Checks for equality with the object’s `countyName` field."""
  countyName: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `stateAbbr` field."""
  stateAbbr: String

  """Checks for equality with the object’s `msaId` field."""
  msaId: String

  """Checks for equality with the object’s `msaName` field."""
  msaName: String

  """Checks for equality with the object’s `msaUrlName` field."""
  msaUrlName: String
}

"""A connection to a list of `MsaCasesAll` values."""
type MsaCasesAllsConnection {
  """A list of `MsaCasesAll` objects."""
  nodes: [MsaCasesAll]!

  """
  A list of edges which contains the `MsaCasesAll` and cursor to aid in pagination.
  """
  edges: [MsaCasesAllsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MsaCasesAll` you could get from the connection."""
  totalCount: Int!
}

type MsaCasesAll {
  msdId: String
  date: String
  confirmedCases: Int
  deaths: Int
}

"""A `MsaCasesAll` edge in the connection."""
type MsaCasesAllsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MsaCasesAll` at the end of the edge."""
  node: MsaCasesAll
}

"""Methods to use when ordering `MsaCasesAll`."""
enum MsaCasesAllsOrderBy {
  NATURAL
  MSD_ID_ASC
  MSD_ID_DESC
  DATE_ASC
  DATE_DESC
  CONFIRMED_CASES_ASC
  CONFIRMED_CASES_DESC
  DEATHS_ASC
  DEATHS_DESC
}

"""
A condition to be used against `MsaCasesAll` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MsaCasesAllCondition {
  """Checks for equality with the object’s `msdId` field."""
  msdId: String

  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `confirmedCases` field."""
  confirmedCases: Int

  """Checks for equality with the object’s `deaths` field."""
  deaths: Int
}

"""A connection to a list of `MsaMeta` values."""
type MsaMetasConnection {
  """A list of `MsaMeta` objects."""
  nodes: [MsaMeta]!

  """
  A list of edges which contains the `MsaMeta` and cursor to aid in pagination.
  """
  edges: [MsaMetasEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MsaMeta` you could get from the connection."""
  totalCount: Int!
}

type MsaMeta {
  msaId: String
  msaName: String
  msaUrlName: String
  stateFipsCode: String
  stateName: String
  statePostalAbbreviation: String
  population: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `MsaMeta` edge in the connection."""
type MsaMetasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MsaMeta` at the end of the edge."""
  node: MsaMeta
}

"""Methods to use when ordering `MsaMeta`."""
enum MsaMetasOrderBy {
  NATURAL
  MSA_ID_ASC
  MSA_ID_DESC
  MSA_NAME_ASC
  MSA_NAME_DESC
  MSA_URL_NAME_ASC
  MSA_URL_NAME_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  STATE_POSTAL_ABBREVIATION_ASC
  STATE_POSTAL_ABBREVIATION_DESC
  POPULATION_ASC
  POPULATION_DESC
}

"""
A condition to be used against `MsaMeta` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MsaMetaCondition {
  """Checks for equality with the object’s `msaId` field."""
  msaId: String

  """Checks for equality with the object’s `msaName` field."""
  msaName: String

  """Checks for equality with the object’s `msaUrlName` field."""
  msaUrlName: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `statePostalAbbreviation` field."""
  statePostalAbbreviation: String

  """Checks for equality with the object’s `population` field."""
  population: BigInt
}

"""A connection to a list of `StateCasesAll` values."""
type StateCasesAllsConnection {
  """A list of `StateCasesAll` objects."""
  nodes: [StateCasesAll]!

  """
  A list of edges which contains the `StateCasesAll` and cursor to aid in pagination.
  """
  edges: [StateCasesAllsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StateCasesAll` you could get from the connection."""
  totalCount: Int!
}

type StateCasesAll {
  date: String
  stateName: String
  stateFipsCode: String
  confirmedCases: Int
  deaths: Int
}

"""A `StateCasesAll` edge in the connection."""
type StateCasesAllsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StateCasesAll` at the end of the edge."""
  node: StateCasesAll
}

"""Methods to use when ordering `StateCasesAll`."""
enum StateCasesAllsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
  CONFIRMED_CASES_ASC
  CONFIRMED_CASES_DESC
  DEATHS_ASC
  DEATHS_DESC
}

"""
A condition to be used against `StateCasesAll` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input StateCasesAllCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String

  """Checks for equality with the object’s `confirmedCases` field."""
  confirmedCases: Int

  """Checks for equality with the object’s `deaths` field."""
  deaths: Int
}

"""A connection to a list of `StateMeta` values."""
type StateMetasConnection {
  """A list of `StateMeta` objects."""
  nodes: [StateMeta]!

  """
  A list of edges which contains the `StateMeta` and cursor to aid in pagination.
  """
  edges: [StateMetasEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StateMeta` you could get from the connection."""
  totalCount: Int!
}

type StateMeta {
  stateFipsCode: String
  stateAbbr: String
  stateName: String
  population: Int
}

"""A `StateMeta` edge in the connection."""
type StateMetasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StateMeta` at the end of the edge."""
  node: StateMeta
}

"""Methods to use when ordering `StateMeta`."""
enum StateMetasOrderBy {
  NATURAL
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
  STATE_ABBR_ASC
  STATE_ABBR_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  POPULATION_ASC
  POPULATION_DESC
}

"""
A condition to be used against `StateMeta` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input StateMetaCondition {
  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String

  """Checks for equality with the object’s `stateAbbr` field."""
  stateAbbr: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `population` field."""
  population: Int
}

"""A connection to a list of `StatesHospitalization` values."""
type StatesHospitalizationsConnection {
  """A list of `StatesHospitalization` objects."""
  nodes: [StatesHospitalization]!

  """
  A list of edges which contains the `StatesHospitalization` and cursor to aid in pagination.
  """
  edges: [StatesHospitalizationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `StatesHospitalization` you could get from the connection.
  """
  totalCount: Int!
}

type StatesHospitalization {
  date: String
  adultIcuBedUsed: Int
  inIcuCurrently: Int
  hospitalizedCurrently: Int
  adultIcuBedsCapacity: Int
  inpatientBedsUsed: Int
  inpatientBedsCapacity: Int
  state: String
  statePostalAbbreviation: String
  stateName: String
  stateGnisid: String
  stateFipsCode: String
}

"""A `StatesHospitalization` edge in the connection."""
type StatesHospitalizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StatesHospitalization` at the end of the edge."""
  node: StatesHospitalization
}

"""Methods to use when ordering `StatesHospitalization`."""
enum StatesHospitalizationsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  ADULT_ICU_BED_USED_ASC
  ADULT_ICU_BED_USED_DESC
  IN_ICU_CURRENTLY_ASC
  IN_ICU_CURRENTLY_DESC
  HOSPITALIZED_CURRENTLY_ASC
  HOSPITALIZED_CURRENTLY_DESC
  ADULT_ICU_BEDS_CAPACITY_ASC
  ADULT_ICU_BEDS_CAPACITY_DESC
  INPATIENT_BEDS_USED_ASC
  INPATIENT_BEDS_USED_DESC
  INPATIENT_BEDS_CAPACITY_ASC
  INPATIENT_BEDS_CAPACITY_DESC
  STATE_ASC
  STATE_DESC
  STATE_POSTAL_ABBREVIATION_ASC
  STATE_POSTAL_ABBREVIATION_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  STATE_GNISID_ASC
  STATE_GNISID_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
}

"""
A condition to be used against `StatesHospitalization` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input StatesHospitalizationCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `adultIcuBedUsed` field."""
  adultIcuBedUsed: Int

  """Checks for equality with the object’s `inIcuCurrently` field."""
  inIcuCurrently: Int

  """Checks for equality with the object’s `hospitalizedCurrently` field."""
  hospitalizedCurrently: Int

  """Checks for equality with the object’s `adultIcuBedsCapacity` field."""
  adultIcuBedsCapacity: Int

  """Checks for equality with the object’s `inpatientBedsUsed` field."""
  inpatientBedsUsed: Int

  """Checks for equality with the object’s `inpatientBedsCapacity` field."""
  inpatientBedsCapacity: Int

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `statePostalAbbreviation` field."""
  statePostalAbbreviation: String

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `stateGnisid` field."""
  stateGnisid: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String
}

"""A connection to a list of `StatesTesting` values."""
type StatesTestingsConnection {
  """A list of `StatesTesting` objects."""
  nodes: [StatesTesting]!

  """
  A list of edges which contains the `StatesTesting` and cursor to aid in pagination.
  """
  edges: [StatesTestingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StatesTesting` you could get from the connection."""
  totalCount: Int!
}

type StatesTesting {
  date: String
  totalTestResults: Int
  negativeIncrease: Int
  positiveIncrease: Int
  stateName: String
  negative: Int
  totalTestResultsIncrease: Int
  positive: Int
  inconclusive: Int
  inconclusiveIncrease: Int
  state: String
  stateFipsCode: String
}

"""A `StatesTesting` edge in the connection."""
type StatesTestingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StatesTesting` at the end of the edge."""
  node: StatesTesting
}

"""Methods to use when ordering `StatesTesting`."""
enum StatesTestingsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  TOTAL_TEST_RESULTS_ASC
  TOTAL_TEST_RESULTS_DESC
  NEGATIVE_INCREASE_ASC
  NEGATIVE_INCREASE_DESC
  POSITIVE_INCREASE_ASC
  POSITIVE_INCREASE_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  NEGATIVE_ASC
  NEGATIVE_DESC
  TOTAL_TEST_RESULTS_INCREASE_ASC
  TOTAL_TEST_RESULTS_INCREASE_DESC
  POSITIVE_ASC
  POSITIVE_DESC
  INCONCLUSIVE_ASC
  INCONCLUSIVE_DESC
  INCONCLUSIVE_INCREASE_ASC
  INCONCLUSIVE_INCREASE_DESC
  STATE_ASC
  STATE_DESC
  STATE_FIPS_CODE_ASC
  STATE_FIPS_CODE_DESC
}

"""
A condition to be used against `StatesTesting` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input StatesTestingCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `totalTestResults` field."""
  totalTestResults: Int

  """Checks for equality with the object’s `negativeIncrease` field."""
  negativeIncrease: Int

  """Checks for equality with the object’s `positiveIncrease` field."""
  positiveIncrease: Int

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `negative` field."""
  negative: Int

  """
  Checks for equality with the object’s `totalTestResultsIncrease` field.
  """
  totalTestResultsIncrease: Int

  """Checks for equality with the object’s `positive` field."""
  positive: Int

  """Checks for equality with the object’s `inconclusive` field."""
  inconclusive: Int

  """Checks for equality with the object’s `inconclusiveIncrease` field."""
  inconclusiveIncrease: Int

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `stateFipsCode` field."""
  stateFipsCode: String
}

"""A connection to a list of `UsCasesAll` values."""
type UsCasesAllsConnection {
  """A list of `UsCasesAll` objects."""
  nodes: [UsCasesAll]!

  """
  A list of edges which contains the `UsCasesAll` and cursor to aid in pagination.
  """
  edges: [UsCasesAllsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UsCasesAll` you could get from the connection."""
  totalCount: Int!
}

type UsCasesAll {
  date: String
  confirmedCases: Int
  deaths: Int
}

"""A `UsCasesAll` edge in the connection."""
type UsCasesAllsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UsCasesAll` at the end of the edge."""
  node: UsCasesAll
}

"""Methods to use when ordering `UsCasesAll`."""
enum UsCasesAllsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  CONFIRMED_CASES_ASC
  CONFIRMED_CASES_DESC
  DEATHS_ASC
  DEATHS_DESC
}

"""
A condition to be used against `UsCasesAll` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UsCasesAllCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `confirmedCases` field."""
  confirmedCases: Int

  """Checks for equality with the object’s `deaths` field."""
  deaths: Int
}

"""A connection to a list of `UsHospitalization` values."""
type UsHospitalizationsConnection {
  """A list of `UsHospitalization` objects."""
  nodes: [UsHospitalization]!

  """
  A list of edges which contains the `UsHospitalization` and cursor to aid in pagination.
  """
  edges: [UsHospitalizationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UsHospitalization` you could get from the connection.
  """
  totalCount: Int!
}

type UsHospitalization {
  date: String
  adultIcuBedUsed: Int
  inIcuCurrently: Int
  hospitalizedCurrently: Int
  adultIcuBedsCapacity: Int
  inpatientBedsUsed: Int
  inpatientBedsCapacity: Int
}

"""A `UsHospitalization` edge in the connection."""
type UsHospitalizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UsHospitalization` at the end of the edge."""
  node: UsHospitalization
}

"""Methods to use when ordering `UsHospitalization`."""
enum UsHospitalizationsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  ADULT_ICU_BED_USED_ASC
  ADULT_ICU_BED_USED_DESC
  IN_ICU_CURRENTLY_ASC
  IN_ICU_CURRENTLY_DESC
  HOSPITALIZED_CURRENTLY_ASC
  HOSPITALIZED_CURRENTLY_DESC
  ADULT_ICU_BEDS_CAPACITY_ASC
  ADULT_ICU_BEDS_CAPACITY_DESC
  INPATIENT_BEDS_USED_ASC
  INPATIENT_BEDS_USED_DESC
  INPATIENT_BEDS_CAPACITY_ASC
  INPATIENT_BEDS_CAPACITY_DESC
}

"""
A condition to be used against `UsHospitalization` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UsHospitalizationCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `adultIcuBedUsed` field."""
  adultIcuBedUsed: Int

  """Checks for equality with the object’s `inIcuCurrently` field."""
  inIcuCurrently: Int

  """Checks for equality with the object’s `hospitalizedCurrently` field."""
  hospitalizedCurrently: Int

  """Checks for equality with the object’s `adultIcuBedsCapacity` field."""
  adultIcuBedsCapacity: Int

  """Checks for equality with the object’s `inpatientBedsUsed` field."""
  inpatientBedsUsed: Int

  """Checks for equality with the object’s `inpatientBedsCapacity` field."""
  inpatientBedsCapacity: Int
}

"""A connection to a list of `UsTesting` values."""
type UsTestingsConnection {
  """A list of `UsTesting` objects."""
  nodes: [UsTesting]!

  """
  A list of edges which contains the `UsTesting` and cursor to aid in pagination.
  """
  edges: [UsTestingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UsTesting` you could get from the connection."""
  totalCount: Int!
}

type UsTesting {
  date: String
  totalTestResults: Int
  negativeIncrease: Int
  positiveIncrease: Int
  stateName: String
  negative: Int
  totalTestResultsIncrease: Int
  positive: Int
  inconclusive: Int
  inconclusiveIncrease: Int
}

"""A `UsTesting` edge in the connection."""
type UsTestingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UsTesting` at the end of the edge."""
  node: UsTesting
}

"""Methods to use when ordering `UsTesting`."""
enum UsTestingsOrderBy {
  NATURAL
  DATE_ASC
  DATE_DESC
  TOTAL_TEST_RESULTS_ASC
  TOTAL_TEST_RESULTS_DESC
  NEGATIVE_INCREASE_ASC
  NEGATIVE_INCREASE_DESC
  POSITIVE_INCREASE_ASC
  POSITIVE_INCREASE_DESC
  STATE_NAME_ASC
  STATE_NAME_DESC
  NEGATIVE_ASC
  NEGATIVE_DESC
  TOTAL_TEST_RESULTS_INCREASE_ASC
  TOTAL_TEST_RESULTS_INCREASE_DESC
  POSITIVE_ASC
  POSITIVE_DESC
  INCONCLUSIVE_ASC
  INCONCLUSIVE_DESC
  INCONCLUSIVE_INCREASE_ASC
  INCONCLUSIVE_INCREASE_DESC
}

"""
A condition to be used against `UsTesting` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UsTestingCondition {
  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `totalTestResults` field."""
  totalTestResults: Int

  """Checks for equality with the object’s `negativeIncrease` field."""
  negativeIncrease: Int

  """Checks for equality with the object’s `positiveIncrease` field."""
  positiveIncrease: Int

  """Checks for equality with the object’s `stateName` field."""
  stateName: String

  """Checks for equality with the object’s `negative` field."""
  negative: Int

  """
  Checks for equality with the object’s `totalTestResultsIncrease` field.
  """
  totalTestResultsIncrease: Int

  """Checks for equality with the object’s `positive` field."""
  positive: Int

  """Checks for equality with the object’s `inconclusive` field."""
  inconclusive: Int

  """Checks for equality with the object’s `inconclusiveIncrease` field."""
  inconclusiveIncrease: Int
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `CountyCasesAll`."""
  createCountyCasesAll(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCountyCasesAllInput!
  ): CreateCountyCasesAllPayload

  """Creates a single `CountyMeta`."""
  createCountyMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCountyMetaInput!
  ): CreateCountyMetaPayload

  """Creates a single `MsaCasesAll`."""
  createMsaCasesAll(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMsaCasesAllInput!
  ): CreateMsaCasesAllPayload

  """Creates a single `MsaMeta`."""
  createMsaMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMsaMetaInput!
  ): CreateMsaMetaPayload

  """Creates a single `StateCasesAll`."""
  createStateCasesAll(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStateCasesAllInput!
  ): CreateStateCasesAllPayload

  """Creates a single `StateMeta`."""
  createStateMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStateMetaInput!
  ): CreateStateMetaPayload

  """Creates a single `StatesHospitalization`."""
  createStatesHospitalization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStatesHospitalizationInput!
  ): CreateStatesHospitalizationPayload

  """Creates a single `StatesTesting`."""
  createStatesTesting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStatesTestingInput!
  ): CreateStatesTestingPayload

  """Creates a single `UsCasesAll`."""
  createUsCasesAll(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUsCasesAllInput!
  ): CreateUsCasesAllPayload

  """Creates a single `UsHospitalization`."""
  createUsHospitalization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUsHospitalizationInput!
  ): CreateUsHospitalizationPayload

  """Creates a single `UsTesting`."""
  createUsTesting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUsTestingInput!
  ): CreateUsTestingPayload
}

"""The output of our create `CountyCasesAll` mutation."""
type CreateCountyCasesAllPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CountyCasesAll` that was created by this mutation."""
  countyCasesAll: CountyCasesAll

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CountyCasesAll`. May be used by Relay 1."""
  countyCasesAllEdge(
    """The method to use when ordering `CountyCasesAll`."""
    orderBy: [CountyCasesAllsOrderBy!] = [NATURAL]
  ): CountyCasesAllsEdge
}

"""All input for the create `CountyCasesAll` mutation."""
input CreateCountyCasesAllInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CountyCasesAll` to be created by this mutation."""
  countyCasesAll: CountyCasesAllInput!
}

"""An input for mutations affecting `CountyCasesAll`"""
input CountyCasesAllInput {
  date: String
  county: String
  stateName: String
  stateFipsCode: String
  countyFipsCode: String
  confirmedCases: Int
  deaths: Int
}

"""The output of our create `CountyMeta` mutation."""
type CreateCountyMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CountyMeta` that was created by this mutation."""
  countyMeta: CountyMeta

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CountyMeta`. May be used by Relay 1."""
  countyMetaEdge(
    """The method to use when ordering `CountyMeta`."""
    orderBy: [CountyMetasOrderBy!] = [NATURAL]
  ): CountyMetasEdge
}

"""All input for the create `CountyMeta` mutation."""
input CreateCountyMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CountyMeta` to be created by this mutation."""
  countyMeta: CountyMetaInput!
}

"""An input for mutations affecting `CountyMeta`"""
input CountyMetaInput {
  countyFipsCode: String
  stateFipsCode: String
  population: Int
  countyName: String
  stateName: String
  stateAbbr: String
  msaId: String
  msaName: String
  msaUrlName: String
}

"""The output of our create `MsaCasesAll` mutation."""
type CreateMsaCasesAllPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MsaCasesAll` that was created by this mutation."""
  msaCasesAll: MsaCasesAll

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MsaCasesAll`. May be used by Relay 1."""
  msaCasesAllEdge(
    """The method to use when ordering `MsaCasesAll`."""
    orderBy: [MsaCasesAllsOrderBy!] = [NATURAL]
  ): MsaCasesAllsEdge
}

"""All input for the create `MsaCasesAll` mutation."""
input CreateMsaCasesAllInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MsaCasesAll` to be created by this mutation."""
  msaCasesAll: MsaCasesAllInput!
}

"""An input for mutations affecting `MsaCasesAll`"""
input MsaCasesAllInput {
  msdId: String
  date: String
  confirmedCases: Int
  deaths: Int
}

"""The output of our create `MsaMeta` mutation."""
type CreateMsaMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MsaMeta` that was created by this mutation."""
  msaMeta: MsaMeta

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MsaMeta`. May be used by Relay 1."""
  msaMetaEdge(
    """The method to use when ordering `MsaMeta`."""
    orderBy: [MsaMetasOrderBy!] = [NATURAL]
  ): MsaMetasEdge
}

"""All input for the create `MsaMeta` mutation."""
input CreateMsaMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MsaMeta` to be created by this mutation."""
  msaMeta: MsaMetaInput!
}

"""An input for mutations affecting `MsaMeta`"""
input MsaMetaInput {
  msaId: String
  msaName: String
  msaUrlName: String
  stateFipsCode: String
  stateName: String
  statePostalAbbreviation: String
  population: BigInt
}

"""The output of our create `StateCasesAll` mutation."""
type CreateStateCasesAllPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StateCasesAll` that was created by this mutation."""
  stateCasesAll: StateCasesAll

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StateCasesAll`. May be used by Relay 1."""
  stateCasesAllEdge(
    """The method to use when ordering `StateCasesAll`."""
    orderBy: [StateCasesAllsOrderBy!] = [NATURAL]
  ): StateCasesAllsEdge
}

"""All input for the create `StateCasesAll` mutation."""
input CreateStateCasesAllInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StateCasesAll` to be created by this mutation."""
  stateCasesAll: StateCasesAllInput!
}

"""An input for mutations affecting `StateCasesAll`"""
input StateCasesAllInput {
  date: String
  stateName: String
  stateFipsCode: String
  confirmedCases: Int
  deaths: Int
}

"""The output of our create `StateMeta` mutation."""
type CreateStateMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StateMeta` that was created by this mutation."""
  stateMeta: StateMeta

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StateMeta`. May be used by Relay 1."""
  stateMetaEdge(
    """The method to use when ordering `StateMeta`."""
    orderBy: [StateMetasOrderBy!] = [NATURAL]
  ): StateMetasEdge
}

"""All input for the create `StateMeta` mutation."""
input CreateStateMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StateMeta` to be created by this mutation."""
  stateMeta: StateMetaInput!
}

"""An input for mutations affecting `StateMeta`"""
input StateMetaInput {
  stateFipsCode: String
  stateAbbr: String
  stateName: String
  population: Int
}

"""The output of our create `StatesHospitalization` mutation."""
type CreateStatesHospitalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StatesHospitalization` that was created by this mutation."""
  statesHospitalization: StatesHospitalization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StatesHospitalization`. May be used by Relay 1."""
  statesHospitalizationEdge(
    """The method to use when ordering `StatesHospitalization`."""
    orderBy: [StatesHospitalizationsOrderBy!] = [NATURAL]
  ): StatesHospitalizationsEdge
}

"""All input for the create `StatesHospitalization` mutation."""
input CreateStatesHospitalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StatesHospitalization` to be created by this mutation."""
  statesHospitalization: StatesHospitalizationInput!
}

"""An input for mutations affecting `StatesHospitalization`"""
input StatesHospitalizationInput {
  date: String
  adultIcuBedUsed: Int
  inIcuCurrently: Int
  hospitalizedCurrently: Int
  adultIcuBedsCapacity: Int
  inpatientBedsUsed: Int
  inpatientBedsCapacity: Int
  state: String
  statePostalAbbreviation: String
  stateName: String
  stateGnisid: String
  stateFipsCode: String
}

"""The output of our create `StatesTesting` mutation."""
type CreateStatesTestingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StatesTesting` that was created by this mutation."""
  statesTesting: StatesTesting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StatesTesting`. May be used by Relay 1."""
  statesTestingEdge(
    """The method to use when ordering `StatesTesting`."""
    orderBy: [StatesTestingsOrderBy!] = [NATURAL]
  ): StatesTestingsEdge
}

"""All input for the create `StatesTesting` mutation."""
input CreateStatesTestingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StatesTesting` to be created by this mutation."""
  statesTesting: StatesTestingInput!
}

"""An input for mutations affecting `StatesTesting`"""
input StatesTestingInput {
  date: String
  totalTestResults: Int
  negativeIncrease: Int
  positiveIncrease: Int
  stateName: String
  negative: Int
  totalTestResultsIncrease: Int
  positive: Int
  inconclusive: Int
  inconclusiveIncrease: Int
  state: String
  stateFipsCode: String
}

"""The output of our create `UsCasesAll` mutation."""
type CreateUsCasesAllPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UsCasesAll` that was created by this mutation."""
  usCasesAll: UsCasesAll

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UsCasesAll`. May be used by Relay 1."""
  usCasesAllEdge(
    """The method to use when ordering `UsCasesAll`."""
    orderBy: [UsCasesAllsOrderBy!] = [NATURAL]
  ): UsCasesAllsEdge
}

"""All input for the create `UsCasesAll` mutation."""
input CreateUsCasesAllInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UsCasesAll` to be created by this mutation."""
  usCasesAll: UsCasesAllInput!
}

"""An input for mutations affecting `UsCasesAll`"""
input UsCasesAllInput {
  date: String
  confirmedCases: Int
  deaths: Int
}

"""The output of our create `UsHospitalization` mutation."""
type CreateUsHospitalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UsHospitalization` that was created by this mutation."""
  usHospitalization: UsHospitalization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UsHospitalization`. May be used by Relay 1."""
  usHospitalizationEdge(
    """The method to use when ordering `UsHospitalization`."""
    orderBy: [UsHospitalizationsOrderBy!] = [NATURAL]
  ): UsHospitalizationsEdge
}

"""All input for the create `UsHospitalization` mutation."""
input CreateUsHospitalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UsHospitalization` to be created by this mutation."""
  usHospitalization: UsHospitalizationInput!
}

"""An input for mutations affecting `UsHospitalization`"""
input UsHospitalizationInput {
  date: String
  adultIcuBedUsed: Int
  inIcuCurrently: Int
  hospitalizedCurrently: Int
  adultIcuBedsCapacity: Int
  inpatientBedsUsed: Int
  inpatientBedsCapacity: Int
}

"""The output of our create `UsTesting` mutation."""
type CreateUsTestingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UsTesting` that was created by this mutation."""
  usTesting: UsTesting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UsTesting`. May be used by Relay 1."""
  usTestingEdge(
    """The method to use when ordering `UsTesting`."""
    orderBy: [UsTestingsOrderBy!] = [NATURAL]
  ): UsTestingsEdge
}

"""All input for the create `UsTesting` mutation."""
input CreateUsTestingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UsTesting` to be created by this mutation."""
  usTesting: UsTestingInput!
}

"""An input for mutations affecting `UsTesting`"""
input UsTestingInput {
  date: String
  totalTestResults: Int
  negativeIncrease: Int
  positiveIncrease: Int
  stateName: String
  negative: Int
  totalTestResultsIncrease: Int
  positive: Int
  inconclusive: Int
  inconclusiveIncrease: Int
}
